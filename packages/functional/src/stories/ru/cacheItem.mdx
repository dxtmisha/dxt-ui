import {Meta} from '@storybook/addon-docs/blocks'

<Meta title='@dxtmisha/functional/ru/Classes/CacheItem'/>

# Класс CacheItem

Низкоуровневый класс для управления одним кешированным значением с автоматической инвалидацией на основе данных сравнения. Этот класс используется внутри класса Cache, но также может использоваться напрямую для точного контроля кеша.

## Основные возможности

- **Кеширование одного значения** — управляет одним кешированным значением с интеллектуальной инвалидацией
- **Инвалидация на основе сравнения** — автоматически инвалидирует кеш при изменении данных сравнения
- **Отслеживание предыдущего значения** — сохраняет ссылку на старое кешированное значение во время обновлений
- **Поддержка синхронного и асинхронного режимов** — выполнение как синхронных, так и асинхронных callback
- **Типобезопасность** — полная поддержка TypeScript с дженериками
- **Эффективное использование памяти** — минимальные накладные расходы для хранения одного значения

## Конструктор

### `constructor`

Создаёт новый экземпляр CacheItem с предоставленной callback функцией.

**Параметры:**
- `callback: () => T` — функция для выполнения когда кеш нужно сгенерировать или обновить

```javascript
import { CacheItem } from '@dxtmisha/functional'

// Простой элемент кеша для дорогих вычислений
const expensiveComputation = new CacheItem(() => {
  console.log('Выполнение дорогих вычислений...')
  return Math.random() * 1000
})

// Элемент кеша для API данных
const apiData = new CacheItem(() => {
  console.log('Получение из API...')
  return fetch('/api/data').then(r => r.json())
})
```

## Методы получения данных

### `getCache`

Получает кешированные данные или выполняет callback для генерации новых данных если кеш недействителен.

**Параметры:**
- `comparison: any[]` — массив значений, используемых для сравнения при инвалидации кеша

**Возвращает:** `T` — кешированные данные или результат выполнения callback

```javascript
const userCache = new CacheItem(() => {
  console.log('Загрузка данных пользователя...')
  return { id: 1, name: 'Иван Иванов', role: 'admin' }
})

let userId = 1
let userRole = 'admin'

// Первый вызов - выполняет callback
const user1 = userCache.getCache([userId, userRole])
console.log(user1) // Лог: "Загрузка данных пользователя..." затем возвращает объект пользователя

// Второй вызов с тем же сравнением - возвращает кешированные данные
const user1Cached = userCache.getCache([userId, userRole])
console.log(user1Cached) // Возвращает кешированные данные без логирования

// Изменение данных сравнения - кеш инвалидирован
userId = 2
const user2 = userCache.getCache([userId, userRole])
console.log(user2) // Лог: "Загрузка данных пользователя..." затем возвращает новый объект пользователя
```

### `getCacheAsync`

Асинхронно получает кешированные данные или выполняет асинхронный callback для генерации новых данных.

**Параметры:**
- `comparison: any[]` — массив значений, используемых для сравнения при инвалидации кеша

**Возвращает:** `Promise<T>` — промис, разрешающийся в кешированные данные или результат callback

```javascript
const apiCache = new CacheItem(async () => {
  console.log('Получение пользователя из API...')
  const response = await fetch('/api/user/1')
  return await response.json()
})

// Первый вызов - выполняет асинхронный callback
const user = await apiCache.getCacheAsync([])
console.log(user) // Лог: "Получение пользователя из API..." затем возвращает данные пользователя

// Второй вызов - возвращает кешированные данные
const userCached = await apiCache.getCacheAsync([])
console.log(userCached) // Возвращает кешированные данные без API вызова
```

### `getCacheOld`

Возвращает предыдущее кешированное значение (до последнего обновления).

**Возвращает:** `T | undefined` — предыдущее кешированное значение или undefined если нет предыдущего значения

```javascript
const dataCache = new CacheItem(() => ({ timestamp: Date.now() }))

// Получить начальные данные
const data1 = dataCache.getCache(['v1'])
console.log(dataCache.getCacheOld()) // undefined (нет предыдущего значения)

// Обновить кеш с новым сравнением
const data2 = dataCache.getCache(['v2'])
console.log(dataCache.getCacheOld()) // Возвращает data1 (предыдущее значение)

// Обновить снова
const data3 = dataCache.getCache(['v3'])
console.log(dataCache.getCacheOld()) // Возвращает data2 (предыдущее значение)
```

## Практические примеры

### Валидация форм с историей

```javascript
class FieldValidator {
  constructor(validationRules) {
    this.validationCache = new CacheItem(() => {
      console.log(`Валидация поля с правилами: ${this.currentRules.join(', ')}`)

      return this.currentRules.map(rule => ({
        rule,
        isValid: this.applyRule(rule, this.currentValue),
        message: this.getRuleMessage(rule, this.currentValue)
      }))
    })

    this.rules = validationRules
    this.currentValue = ''
    this.currentRules = []
  }

  validate(value, activeRules = this.rules) {
    this.currentValue = value
    this.currentRules = activeRules

    const validation = this.validationCache.getCache([value, activeRules.join(',')])
    const previousValidation = this.validationCache.getCacheOld()

    return {
      current: validation,
      previous: previousValidation,
      hasChanged: !!previousValidation &&
                  JSON.stringify(validation) !== JSON.stringify(previousValidation)
    }
  }

  applyRule(rule, value) {
    switch (rule) {
      case 'required': return value.length > 0
      case 'minLength': return value.length >= 3
      case 'email': return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value)
      default: return true
    }
  }

  getRuleMessage(rule, value) {
    if (this.applyRule(rule, value)) return null

    switch (rule) {
      case 'required': return 'Поле обязательно'
      case 'minLength': return 'Минимум 3 символа'
      case 'email': return 'Неверный формат email'
      default: return 'Недопустимое значение'
    }
  }
}

// Использование
const validator = new FieldValidator(['required', 'email'])

// Валидация пустого поля
const result1 = validator.validate('')
console.log(result1.current) // Валидирует и показывает ошибку обязательности
console.log(result1.previous) // undefined

// Валидация неверного email
const result2 = validator.validate('invalid-email')
console.log(result2.current) // Валидирует и показывает ошибку email
console.log(result2.previous) // Предыдущий результат валидации
console.log(result2.hasChanged) // true

// Валидация корректного email (кешируется если те же правила)
const result3 = validator.validate('invalid-email')
console.log(result3.hasChanged) // false (кешированный результат)
```

### Вычисляемые свойства с зависимостями

```javascript
class DataProcessor {
  constructor(initialData = []) {
    this.rawData = initialData
    this.filters = { status: 'active', category: 'all' }

    this.processedDataCache = new CacheItem(() => {
      console.log('Обработка данных с фильтрами:', this.filters)

      const start = performance.now()
      const result = this.rawData
        .filter(item => this.filters.status === 'all' || item.status === this.filters.status)
        .filter(item => this.filters.category === 'all' || item.category === this.filters.category)
        .map(item => ({
          ...item,
          processed: true,
          processedAt: new Date().toISOString()
        }))

      const duration = performance.now() - start
      console.log(`Обработка завершена за ${duration.toFixed(2)}мс`)

      return result
    })
  }

  getProcessedData() {
    const processed = this.processedDataCache.getCache([
      this.rawData.length,
      JSON.stringify(this.filters)
    ])

    const previous = this.processedDataCache.getCacheOld()

    return {
      data: processed,
      previousData: previous,
      stats: {
        total: processed.length,
        previousTotal: previous?.length || 0,
        changed: previous ? processed.length !== previous.length : true
      }
    }
  }

  updateFilters(newFilters) {
    this.filters = { ...this.filters, ...newFilters }
    console.log('Фильтры обновлены, кеш инвалидируется при следующем доступе')
  }

  addData(newItems) {
    this.rawData.push(...newItems)
    console.log(`Добавлено ${newItems.length} элементов, кеш инвалидируется`)
  }

  removeData(predicate) {
    const originalLength = this.rawData.length
    this.rawData = this.rawData.filter(item => !predicate(item))
    console.log(`Удалено ${originalLength - this.rawData.length} элементов`)
  }
}

// Использование
const processor = new DataProcessor([
  { id: 1, status: 'active', category: 'tech' },
  { id: 2, status: 'inactive', category: 'design' },
  { id: 3, status: 'active', category: 'tech' }
])

// Первоначальная обработка
const result1 = processor.getProcessedData()
console.log('Первый результат:', result1.stats) // Обрабатывает данные

// Кешированный вызов
const result2 = processor.getProcessedData()
console.log('Кешированный результат:', result2.stats) // Возвращает кешированные данные

// Изменение фильтра
processor.updateFilters({ category: 'tech' })
const result3 = processor.getProcessedData()
console.log('После изменения фильтра:', result3.stats) // Переобрабатывает с новым фильтром
console.log('Длина предыдущих данных:', result3.stats.previousTotal) // Показывает старый счётчик

// Добавление новых данных
processor.addData([{ id: 4, status: 'active', category: 'tech' }])
const result4 = processor.getProcessedData()
console.log('После добавления данных:', result4.stats) // Переобрабатывает с новыми данными
```

### Асинхронный API кеш с восстановлением ошибок

```javascript
class APIManager {
  constructor(baseURL, options = {}) {
    this.baseURL = baseURL
    this.options = { retries: 3, timeout: 5000, ...options }
    this.authToken = null

    this.apiCache = new CacheItem(async () => {
      const endpoint = this.currentEndpoint
      const headers = this.getCurrentHeaders()

      console.log(`Получение: ${endpoint}`)

      let lastError
      for (let attempt = 1; attempt <= this.options.retries; attempt++) {
        try {
          const controller = new AbortController()
          const timeoutId = setTimeout(() => controller.abort(), this.options.timeout)

          const response = await fetch(`${this.baseURL}${endpoint}`, {
            headers,
            signal: controller.signal
          })

          clearTimeout(timeoutId)

          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`)
          }

          const data = await response.json()
          console.log(`Успешно получено: ${endpoint}`)

          return {
            data,
            meta: {
              endpoint,
              timestamp: new Date().toISOString(),
              attempt,
              status: response.status
            }
          }

        } catch (error) {
          lastError = error
          console.warn(`Попытка ${attempt} не удалась:`, error.message)

          if (attempt < this.options.retries) {
            await new Promise(resolve => setTimeout(resolve, 1000 * attempt))
          }
        }
      }

      throw new Error(`Все ${this.options.retries} попытки не удались. Последняя ошибка: ${lastError.message}`)
    })
  }

  async fetchData(endpoint) {
    this.currentEndpoint = endpoint

    try {
      const result = await this.apiCache.getCacheAsync([
        endpoint,
        this.authToken,
        this.options.timeout
      ])

      const previous = this.apiCache.getCacheOld()

      return {
        success: true,
        result: result.data,
        meta: result.meta,
        cached: result === previous,
        previousMeta: previous?.meta
      }

    } catch (error) {
      const previous = this.apiCache.getCacheOld()

      return {
        success: false,
        error: error.message,
        fallbackData: previous?.data,
        hasFallback: !!previous
      }
    }
  }

  getCurrentHeaders() {
    const headers = { 'Content-Type': 'application/json' }
    if (this.authToken) {
      headers.Authorization = `Bearer ${this.authToken}`
    }
    return headers
  }

  setAuthToken(token) {
    this.authToken = token
    console.log('Токен аутентификации обновлён, кеш инвалидируется')
  }

  updateOptions(newOptions) {
    this.options = { ...this.options, ...newOptions }
    console.log('Опции обновлены, кеш инвалидируется')
  }
}

// Использование
const apiManager = new APIManager('https://api.example.com')

async function demonstrateAPI() {
  try {
    // Установка аутентификации
    apiManager.setAuthToken('abc123')

    // Первый вызов - получает из API
    const result1 = await apiManager.fetchData('/users/1')
    console.log('Первый вызов:', result1.success ? 'Успех' : 'Неудача')
    console.log('Данные:', result1.result || result1.error)

    // Кешированный вызов
    const result2 = await apiManager.fetchData('/users/1')
    console.log('Второй вызов кеширован:', result2.cached)

    // Другой endpoint
    const result3 = await apiManager.fetchData('/users/2')
    console.log('Другой endpoint:', result3.meta)

    // Изменение токена инвалидирует кеш
    apiManager.setAuthToken('xyz789')
    const result4 = await apiManager.fetchData('/users/1')
    console.log('После изменения токена:', result4.cached === false)

  } catch (error) {
    console.error('Ошибка демо:', error)
  }
}

// demonstrateAPI()
```

### Мемоизированное состояние компонента

```javascript
class ComponentState {
  constructor(initialState = {}) {
    this.state = { ...initialState }
    this.computedCache = new Map()
  }

  createComputed(name, computeFn, dependencies) {
    this.computedCache.set(name, new CacheItem(computeFn))

    // Возвращает getter функцию
    return () => {
      const deps = dependencies.map(dep => this.getStateValue(dep))
      return this.computedCache.get(name).getCache(deps)
    }
  }

  createAsyncComputed(name, computeFn, dependencies) {
    this.computedCache.set(name, new CacheItem(computeFn))

    // Возвращает асинхронную getter функцию
    return async () => {
      const deps = dependencies.map(dep => this.getStateValue(dep))
      return await this.computedCache.get(name).getCacheAsync(deps)
    }
  }

  setState(updates) {
    this.state = { ...this.state, ...updates }
  }

  getState(key) {
    return key ? this.state[key] : this.state
  }

  getStateValue(path) {
    return path.split('.').reduce((obj, key) => obj?.[key], this.state)
  }

  getComputedHistory(name) {
    const cacheItem = this.computedCache.get(name)
    if (!cacheItem) return null

    return {
      current: cacheItem.getCache([]), // Получить текущее без изменения зависимостей
      previous: cacheItem.getCacheOld()
    }
  }
}

// Пример использования
const appState = new ComponentState({
  user: { id: 1, name: 'Иван' },
  posts: [],
  filters: { status: 'published' }
})

// Создание вычисляемых свойств
const getFilteredPosts = appState.createComputed(
  'filteredPosts',
  () => {
    console.log('Вычисление отфильтрованных постов...')
    return appState.getState('posts').filter(post =>
      post.status === appState.getState('filters.status')
    )
  },
  ['posts', 'filters.status']
)

const getUserProfile = appState.createAsyncComputed(
  'userProfile',
  async () => {
    console.log('Получение профиля пользователя...')
    const user = appState.getState('user')
    // Имитация API вызова
    await new Promise(resolve => setTimeout(resolve, 100))
    return { ...user, profileComplete: !!user.name }
  },
  ['user.id', 'user.name']
)

// Использование
async function demo() {
  // Первоначальное вычисление
  console.log('Отфильтрованные посты:', getFilteredPosts()) // Вычисляет
  console.log('Отфильтрованные посты (кеш):', getFilteredPosts()) // Кешировано

  // Изменение состояния, влияющее на зависимость
  appState.setState({
    posts: [
      { id: 1, status: 'published' },
      { id: 2, status: 'draft' }
    ]
  })

  console.log('После обновления постов:', getFilteredPosts()) // Перевычисляет

  // Проверка истории
  const history = appState.getComputedHistory('filteredPosts')
  console.log('Предыдущий результат:', history.previous) // Показывает старые отфильтрованные посты
  console.log('Текущий результат:', history.current) // Показывает новые отфильтрованные посты

  // Асинхронное вычисляемое свойство
  const profile1 = await getUserProfile() // Получает
  const profile2 = await getUserProfile() // Кешировано
  console.log('Профиль кеширован:', profile1 === profile2)
}

// demo()
```

## Паттерны интеграции

### С Vue Composition API

```javascript
import { ref, computed } from 'vue'
import { CacheItem } from '@dxtmisha/functional'

export function useExpensiveComputation(dependencies) {
  const cache = new CacheItem(() => {
    // Дорогие вычисления здесь
    return dependencies.value.reduce((sum, item) => sum + item.value, 0)
  })

  return computed(() => {
    return cache.getCache([JSON.stringify(dependencies.value)])
  })
}
```

### С React Hooks

```javascript
import { useMemo, useRef } from 'react'
import { CacheItem } from '@dxtmisha/functional'

export function useExpensiveComputation(dependencies) {
  const cacheRef = useRef(null)

  if (!cacheRef.current) {
    cacheRef.current = new CacheItem(() => {
      // Дорогие вычисления здесь
      return dependencies.reduce((sum, item) => sum + item.value, 0)
    })
  }

  return useMemo(() => {
    return cacheRef.current.getCache([JSON.stringify(dependencies)])
  }, [dependencies])
}
```

Класс CacheItem предоставляет точный контроль над отдельными кешированными значениями, делая его идеальным для сценариев, где нужно отслеживать историю значений, реализовывать пользовательскую логику инвалидации или интегрироваться с реактивными системами, сохраняя оптимальную производительность.
