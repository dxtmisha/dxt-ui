## Состояние значения (value и isValue)

`Field` отделяет фактическое содержимое ввода от *визуального состояния заполненности*.

### Свойства

- **value** – Фактическое содержимое (строка/число и т.п.), которое вы передаёте во внутренний `<input>` через слот. `Field` не управляет значением (нет `v-model` и мутаций) и не валидирует его, **но** считывает его ОДИН раз реактивно через вычисление `focusValue` для чисто визуальных целей: вывода «текущего» текста рядом с caption (scoreboardInput) и корректной работы комбинированной зоны caption/доборных элементов. Если передан `props.value` (строка) – используется он; иначе ищется реальный `<input>` или элемент с `[data-length]`. Это чтение не влияет на логику валидации и не изменяет значение.
- **isValue** (`boolean`) – Принудительно включает «режим заполненности» (плавающая / сжатая метка, соответствующие классы), даже если реальный `value` пуст.

### Взаимодействие

1. Реальное непустое значение (через слот) всегда включает визуальное состояние «заполнено» независимо от `isValue`.
2. Пустое значение + `isValue = true` ⇒ поле выглядит заполненным (прелоад, маска, отложенная подстановка).
3. Пустое значение + отсутствие/`false` у `isValue` ⇒ визуально пусто.
4. `focusValue` используется только для отображения текста в зоне scoreboard при активном caption и (опционально) для считывания длины из элемента с `[data-length]`; не применять его для бизнес‑логики.
5. Валидация, helper‑сообщения и счётчик символов (если реализованы вовне) должны опираться на фактическое значение input, а не на `isValue`.

### Когда использовать `isValue`

- Предварительный показ «как будто заполнено», пока грузятся данные.
- Маскированные / шаблонные поля, где нужно зафиксировать плавающий label.
- Демо/сторис без передачи реального значения.

### Рекомендации

- Не подменяйте бизнес‑логику через `isValue`; он только про визуал.
- Если требуется реактивная работа с данными — управляйте значением во внешнем компоненте с `v-model`, а `Field` используйте как каркас.
- Для корректного подсчёта длины можно пометить внутренний элемент атрибутом `data-length`; приоритет чтения: элемент с `[data-length]` → основной `<input>` → `props.value`.
