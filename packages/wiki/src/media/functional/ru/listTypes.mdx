import {Meta} from '@storybook/addon-docs/blocks'

<Meta title='@dxtmisha/functional/ru/Types/listTypes'/>

# Типы списков (listTypes)

Набор специализированных TypeScript типов для работы со списками, элементами данных и их состояниями. Обеспечивает типобезопасность при создании интерактивных списков с поддержкой выбора, фокуса, поиска и группировки.

## Типы элементов списка

### `ListType`

Тип элемента списка, определяющий его назначение и поведение.

```typescript
type ListType = 'item' | 'space' | 'line' | 'subtitle' | 'html' | 'menu' | 'menu-group' | 'group'

// Использование
const listItems: { type: ListType; content: string }[] = [
  { type: 'subtitle', content: 'Основные действия' },
  { type: 'item', content: 'Создать документ' },
  { type: 'item', content: 'Открыть файл' },
  { type: 'line', content: '' }, // разделитель
  { type: 'menu-group', content: 'Настройки' },
  { type: 'menu', content: 'Параметры' },
  { type: 'space', content: '' }, // пустое пространство
  { type: 'html', content: '<strong>HTML контент</strong>' },
  { type: 'group', content: 'Группа элементов' }
]
```

**Типы элементов:**
- `'item'` — обычный элемент списка с возможностью выбора
- `'space'` — пустое пространство для создания отступов
- `'line'` — горизонтальная линия-разделитель
- `'subtitle'` — подзаголовок или категория
- `'html'` — HTML контент
- `'menu'` — элемент меню
- `'menu-group'` — группа элементов меню
- `'group'` — группа связанных элементов

## Базовые структуры данных

### `ListDataBasic`

Базовая структура данных для элемента списка.

```typescript
type ListDataBasic = {
  label?: NumberOrString
  value?: any
  search?: string
}

// Использование
const basicItems: ListDataBasic[] = [
  {
    label: 'Пользователь 1',
    value: { id: 1, name: 'John Doe' },
    search: 'john doe user'
  },
  {
    label: 42,
    value: 'number-item',
    search: 'число 42'
  },
  {
    label: 'Простой элемент'
    // value и search опциональны
  }
]
```

### `ListDataItem<Item>`

Расширенный элемент списка с типом и индексом.

```typescript
type ListDataItem<Item extends ListDataBasic = ListDataBasic> = ConstrBind<
  Item & {
    parent?: string
    type: ListType
    index: string
  }
>

// Использование
interface UserItem extends ListDataBasic {
  label: string
  value: { id: number; email: string }
  avatar?: string
}

const userItems: ListDataItem<UserItem>[] = [
  {
    label: 'Администратор',
    value: { id: 1, email: 'admin@example.com' },
    avatar: '/avatars/admin.jpg',
    type: 'item',
    index: 'user-1',
    parent: 'admin-group',
    class: 'user-item admin',
    style: { backgroundColor: '#f0f0f0' }
  }
]
```

### `ListList<Item>`

Массив элементов данных списка.

```typescript
type ListList<Item extends ListDataBasic = ListDataBasic> = ListDataItem<Item>[]

// Использование
const navigationList: ListList = [
  {
    label: 'Главная',
    value: '/',
    type: 'item',
    index: 'nav-home'
  },
  {
    label: 'О компании',
    value: '/about',
    type: 'item',
    index: 'nav-about'
  }
]
```

### `ListRecord<Item>`

Структура списка или записи для данных списка.

```typescript
type ListRecord<Item extends ListDataBasic = ListDataBasic> = ListList<Item> | Record<string, any>

// Использование как массив
const arrayRecord: ListRecord = [
  { label: 'Item 1', type: 'item', index: '1' },
  { label: 'Item 2', type: 'item', index: '2' }
]

// Использование как объект
const objectRecord: ListRecord = {
  users: { label: 'Пользователи', count: 10 },
  settings: { label: 'Настройки', active: true }
}
```

## Расширенные типы с состоянием

### `ListDataFullItem<Item>`

Расширенный элемент списка с дополнительными свойствами состояния.

```typescript
type ListDataFullItem<Item extends ListDataBasic = ListDataBasic> = ListDataItem<Item> & {
  focus: boolean
  highlight?: string
  selected: boolean
}

// Использование
const interactiveItem: ListDataFullItem = {
  label: 'Активный элемент',
  value: 'active-item',
  type: 'item',
  index: 'item-1',
  focus: true,        // элемент в фокусе
  highlight: 'Актив', // выделенная часть текста
  selected: false     // не выбран
}
```

### `ListDataFull<Item>`

Массив расширенных элементов списка с состоянием.

```typescript
type ListDataFull<Item extends ListDataBasic = ListDataBasic> = ListDataFullItem<Item>[]

// Использование
const interactiveList: ListDataFull = [
  {
    label: 'Первый элемент',
    value: 1,
    type: 'item',
    index: 'item-1',
    focus: false,
    selected: true
  },
  {
    label: 'Второй элемент',
    value: 2,
    type: 'item',
    index: 'item-2',
    focus: true,
    highlight: 'Втор',
    selected: false
  }
]
```

## Входные типы данных

### `ListListInputItem<Item>`

Входной элемент для создания списка.

```typescript
type ListListInputItem<Item extends ListDataBasic = ListDataBasic> = ConstrBind<Item>

// Использование
const inputItem: ListListInputItem = {
  label: 'Новый элемент',
  value: 'new-item',
  search: 'новый элемент поиск',
  class: 'input-item',
  style: { color: 'blue' }
}
```

### `ListListInput<Item>`

Различные форматы входных данных для создания списка.

```typescript
type ListListInput<Item extends ListDataBasic = ListDataBasic> =
  | ListListInputItem<Item>[]
  | string[]
  | Record<string, ListListInputItem<Item>>
  | Record<string, string>

// Массив объектов
const objectArray: ListListInput = [
  { label: 'Элемент 1', value: 1 },
  { label: 'Элемент 2', value: 2 }
]

// Массив строк
const stringArray: ListListInput = ['Опция 1', 'Опция 2', 'Опция 3']

// Объект с объектами
const objectRecord: ListListInput = {
  first: { label: 'Первый', value: 1 },
  second: { label: 'Второй', value: 2 }
}

// Объект со строками
const stringRecord: ListListInput = {
  ru: 'Русский',
  en: 'English',
  de: 'Deutsch'
}
```

## Типы выбора элементов

### `ListSelectedItem`

Идентификатор одного выбранного элемента.

```typescript
type ListSelectedItem = NumberOrStringOrBoolean

// Использование
const selectedItems: ListSelectedItem[] = [
  'item-1',    // строковый ID
  42,          // числовой ID
  true,        // булево значение
  false
]
```

### `ListSelectedList`

Один или несколько выбранных элементов.

```typescript
type ListSelectedList = ListSelectedItem | ListSelectedItem[]

// Одиночный выбор
const singleSelection: ListSelectedList = 'selected-item'

// Множественный выбор
const multipleSelection: ListSelectedList = ['item-1', 'item-2', 42, true]
```

### `ListName`

Название выбранного элемента списка.

```typescript
type ListName = string | number | undefined

// Использование
const itemNames: ListName[] = [
  'home',
  'about',
  42,
  undefined  // элемент без названия
]
```

### `ListNames`

Массив названий выбранных элементов списка.

```typescript
type ListNames = ListName[]

// Использование
const selectedNames: ListNames = ['home', 'profile', 42, undefined]

function getSelectedNames(list: ListDataFull): ListNames {
  return list
    .filter(item => item.selected)
    .map(item => item.label as ListName)
}
```

## Практические примеры

### Система навигации

```typescript
import type { ListDataFull, ListType, ListSelectedList } from '@dxtmisha/functional'

interface NavigationItem extends ListDataBasic {
  label: string
  value: string
  icon?: string
  badge?: number
}

const navigationData: ListDataFull<NavigationItem> = [
  {
    label: 'Панель управления',
    value: '/dashboard',
    icon: 'dashboard',
    type: 'subtitle',
    index: 'nav-dashboard-title',
    focus: false,
    selected: false
  },
  {
    label: 'Главная',
    value: '/dashboard/home',
    icon: 'home',
    type: 'item',
    index: 'nav-home',
    focus: false,
    selected: true
  },
  {
    label: 'Аналитика',
    value: '/dashboard/analytics',
    icon: 'chart',
    badge: 5,
    type: 'item',
    index: 'nav-analytics',
    focus: true,
    selected: false
  }
]
```

### Поисковый список с фильтрацией

```typescript
import type { ListListInput, ListDataFull } from '@dxtmisha/functional'

class SearchableList<T extends ListDataBasic> {
  constructor(private data: ListListInput<T>) {}

  search(query: string): ListDataFull<T> {
    return this.normalizeData(this.data)
      .map(item => ({
        ...item,
        focus: false,
        selected: false,
        highlight: this.getHighlight(item.label?.toString() || '', query)
      }))
      .filter(item => this.matchesSearch(item, query))
  }

  private matchesSearch(item: ListDataFull<T>[0], query: string): boolean {
    const searchText = item.search || item.label?.toString() || ''
    return searchText.toLowerCase().includes(query.toLowerCase())
  }

  private getHighlight(text: string, query: string): string | undefined {
    if (!query) return undefined

    const index = text.toLowerCase().indexOf(query.toLowerCase())
    return index >= 0 ? text.substring(index, index + query.length) : undefined
  }
}
```

### Многоуровневое меню

```typescript
import type { ListDataItem, ListList } from '@dxtmisha/functional'

interface MenuItemData extends ListDataBasic {
  label: string
  value: string
  children?: MenuItemData[]
}

function createNestedMenu(items: MenuItemData[], parentId?: string): ListList<MenuItemData> {
  const result: ListList<MenuItemData> = []

  items.forEach((item, index) => {
    const itemId = `${parentId || 'root'}-${index}`

    // Добавляем основной элемент
    result.push({
      ...item,
      type: 'menu',
      index: itemId,
      parent: parentId
    })

    // Добавляем дочерние элементы
    if (item.children && item.children.length > 0) {
      result.push({
        label: '',
        value: '',
        type: 'menu-group',
        index: `${itemId}-group`,
        parent: itemId
      })

      const childItems = createNestedMenu(item.children, itemId)
      result.push(...childItems)
    }
  })

  return result
}
```

### Управление выбором элементов

```typescript
import type { ListSelectedList, ListDataFull, ListNames } from '@dxtmisha/functional'

class ListSelectionManager {
  constructor(private list: ListDataFull) {}

  getSelected(): ListSelectedList {
    return this.list
      .filter(item => item.selected)
      .map(item => item.value)
  }

  getSelectedNames(): ListNames {
    return this.list
      .filter(item => item.selected)
      .map(item => item.label as ListName)
  }

  selectItems(values: ListSelectedList): void {
    const valuesToSelect = Array.isArray(values) ? values : [values]

    this.list.forEach(item => {
      item.selected = valuesToSelect.includes(item.value)
    })
  }

  toggleSelection(value: ListSelectedItem): void {
    const item = this.list.find(item => item.value === value)
    if (item) {
      item.selected = !item.selected
    }
  }

  clearSelection(): void {
    this.list.forEach(item => {
      item.selected = false
    })
  }
}
```

### Создание списка из различных форматов

```typescript
import type { ListListInput, ListDataItem } from '@dxtmisha/functional'

function createListFromInput<T extends ListDataBasic>(
  input: ListListInput<T>
): ListDataItem<T>[] {
  if (Array.isArray(input)) {
    if (typeof input[0] === 'string') {
      // Массив строк
      return (input as string[]).map((label, index) => ({
        label,
        value: label,
        type: 'item',
        index: `item-${index}`
      }))
    } else {
      // Массив объектов
      return (input as ListListInputItem<T>[]).map((item, index) => ({
        ...item,
        type: 'item',
        index: item.index || `item-${index}`
      }))
    }
  } else {
    // Объект-запись
    return Object.entries(input).map(([key, value]) => {
      if (typeof value === 'string') {
        return {
          label: value,
          value: key,
          type: 'item',
          index: key
        }
      } else {
        return {
          ...value,
          type: 'item',
          index: key
        }
      }
    })
  }
}
```

Эти типы списков обеспечивают полную типизацию для создан��я интерактивных списков, меню, навигации и других компонентов с поддержкой выбора, поиска и группировки элементов.
