Нужно подготовить документацию для компонента на языке [wikiLanguage]. Следуй строго формату и требованиям ниже. Не добавляй ничего лишнего вне описанного.
Стек Storybook 9.x, TypeScript, MDX.

Компонент Canvas подключается из '@storybook/addon-docs/blocks'

====================================
1) Изучи текущий код компонента
====================================
```
[code]
```
Проанализируй структуру, props, события, слоты, типы, внутреннюю логику.

====================================
2) Добавь недостающие комментарии к типам
====================================
Добавь краткие одноязычные (на [wikiLanguage]) JSDoc-комментарии к отсутствующим типам и их свойствам.
Код для исправления:
```ts
// types.ts
[types]
```
Ниже продублируй итог без обёртки:
[types]

Требования к комментариям:
- Однострочные для простых полей.
- Многострочные для блоков логики.
- Без дублирования очевидного.
- Адаптированы к storybook.

Пример:
```ts
/**
 * Basic properties for image components.
 */
export interface IconPropsBasic<
  Image extends ImagePropsBasic = ImagePropsBasic
> extends SkeletonPropsInclude {
  // Status
  /** Active state of the icon */
  active?: boolean

  // Icon
  /** Значение основной иконки */
  icon?: ImageValue<Image>
  /** Значение активной иконки */
  iconActive?: ImageValue<Image>
}
```

====================================
3) Истории (stories) для Storybook
====================================
Создай только минимально необходимые примеры. Каждый пример — максимально простой, без лишних обёрток, только то, что демонстрирует суть.
Код для исправления:
```ts
// ComponentDoc.stories.ts
[stories]
```
Правила:
- Не трогать те stories, которые уже есть, только добавления.
- Не трогать const meta. НИЧЕГО НЕ МЕНЯТЬ В META.
- Не трогать существующие константы.
- Не переименовывай существующие константы.
- Не добавляй истории ради заполнения.
- Если компонент имеет разные режимы (например, состояния или варианты отображения), покажи по одному примеру.
- Имена историй — в стиле PascalCase без лишних слов.
- Минимизируй импорты: только то, что требуется.

====================================
4) MDX-документация (описание компонента)
====================================
Подготовь полное описание компонента в формате MDX. Строгая стилистика: никаких таблиц, никаких лишних разделов.
Код для исправления:
```md
// UiPlayerLite.mdx
[md]
```

Правила структуры MDX:
- В начале: [description] — Краткое описание назначения (1–3 предложения): максимально коротко передаёт суть компонента.
- Далее: основной текст (документация) — начинается без заголовка. Это [doc].
- Можно дорабатывать существующий текст, изменяя, но не удалять. Удаляй только лишнее или неактуальное.
- Обязательно перечисли слоты (если есть) и события (если есть) в заданном формате.
- Не описывай props списком, если они простые. Подробно описывай только сложные связки (например, зависимые props) или составные типы.
- Пример использования — в конце соответствующего смыслового блока или в самом низу, если один общий пример.
- Слоты и события — строго в формате ниже. Если типов нет — блок с типом опускается.
- Добавь Canvas, если есть пример использования. Если нет — добавь stories.
- Не надо добавлять <Canvas of={Component.Component}/>

Формат слотов:
```
## Слоты
### `имяСлота`
Краткое описание назначения слота. Можно маркированным списком выделить особенности.
Если есть props, добавить описание props. `props: any` - это значит, что нет пропсов, его не надо писать.
Если слотов несколько — каждый с подпунктом `###`.
Если возвращает просто VNode, не надо описывать.
Не надо писать что-то в таком виде: `Этот слот принимает любые VNode и не передает никаких свойств.`
Если нет событий, не описывать блок событий.
Если нет слотов, не описывать блок слотов.

Формат событий:
```
## События
### `имяСобытия`
Описание, когда и зачем испускается.

Пример описания слота (не вставляй дословно, адаптируй):
### `suffix`

Слот для размещения контента в конце компонента, после основного содержимого.

**Возвращает:** `VNode` — элемент с классом `{className}__suffix` и атрибутом `data-event-type="suffix"`

```html
<Component>
  <template #suffix>
    <Icon name="check" />
  </template>
</Component>
```

### `control`

Слот для размещения элементов управления окном (кнопки закрытия, минимизации и т.д.).

**Параметры:**
- `props: WindowControlItem` — объект с данными управления окном

```html
<Window>
  <template #control="{ onclick, open }">
    <button @click="onclick">
      {{ open ? 'Закрыть' : 'Открыть' }}
    </button>
  </template>
</Window>
```

Пример описания события (адаптируй под контекст):
### `window`

Событие срабатывает при изменении состояния окна (открытие/закрытие).

**Параметры:**
- `options: WindowEmitOptions` — объект с данными окна

**Структура WindowEmitOptions:**
- `id: string` — уникальный идентификатор окна
- `element: HTMLDivElement` — DOM элемент окна
- `control: HTMLElement` — DOM элемент управления
- `open: boolean` — состояние открытия окна (`true` - открыто, `false` - закрыто)

```html
<script setup>
const handleWindow = (options) => {
  console.log('ID окна:', options.id)
  console.log('Окно открыто:', options.open)
  console.log('Элемент окна:', options.element)
  console.log('Элемент управления:', options.control)
}
</script>

<template>
  <Window @window="handleWindow">
    <template #default>
      <p>Содержимое окна</p>
    </template>
  </Window>
</template>
```


Пример использования Canvas:
<Canvas of={Chip.ChipSkeleton}/>

====================================
5) Итоговый возврат
====================================
Верни результат строго в формате (ничего лишнего до или после):
[types.ts]
#########
[ComponentDoc.stories.ts]
#########
[UiPlayerLite.mdx]

Где:
- Не добавляй ничего лишнего (типа ```ts)
- Не оборачивай в блоки.
- Не оборачивай в ```ts или что-то подобное.
- [types.ts] — итоговый блок типов с комментариями (only content, without file name comments).
- [ComponentDoc.stories.ts] — итоговый файл историй (only content, without file name comments).
- [UiPlayerLite.mdx] — итоговая MDX-документация (only content, without file name comments).

====================================
Ограничения и стилистика
====================================
- Никаких таблиц.
- Никаких произвольных дополнительных разделов.
- Не добавляй раздел "Props", если нет сложных зависимостей.
- Не дублируй описание одного и того же.
- Уважай язык [wikiLanguage] — если это "en" используй английский, иначе соответствующий язык.
- Не используй placeholder'ы вне оговорённых.
- Кодовые блоки: для типов и событий — ```ts, для разметки — ```html при необходимости.
- Сторисы: только необходимые сценарии, без лишних визуальных украшений.

====================================
Пример (не включать в ответ, только как ориентир стиля)
====================================
Компонент для создания модальных окон, диалогов и всплывающих элементов с гибким позиционированием и адаптивным поведением.

Window управляет отображением контента поверх основного интерфейса, поддерживает различные типы позиционирования (модальные окна, выпадающие меню, action sheets), анимации открытия/закрытия и интеграцию с системой событий. Компонент автоматически обрабатывает клики вне области, управление фокусом и адаптацию под различные размеры экранов.

**Основные возможности:**

- Гибкое позиционирование (центр, края, углы экрана)
- Адаптивные режимы (modal, menu, actionSheet, static)
- Анимации открытия/закрытия с настройкой origin
- Управление состоянием через v-model или expose методы
- Интеграция со Scrollbar для прокручиваемого контента
- Блокировка взаимодействия с фоном (persistent режим)
- События жизненного цикла окна

**Типичные сценарии использования:**

- Модальные окна для форм и подтверждений
- Выпадающие меню и контекстные меню
- Боковые панели и drawer компоненты
- Action sheets для мобильных интерфейсов
- Всплывающие подсказки и диалоги

## CSS классы для управления поведением

- `*--block` — предотвращает закрытие окна при клике вне его границ
- `*--blockChildren` — предотвращает закрытие текущего окна
- `*--blockOther` — предотвращает закрытие других окон до закрытия текущего
- `*--close` — применяется к элементам для закрытия окна
- `*--controlOpenOnly` — применяется к элементам управления, которые только открывают окно
- `*--controlStatic` — применяется к элементам управления в статическом режиме
- `*--static` — применяется к элементам внутри окна, отменяя все действия

Где `*` — название класса компонента (например, `d1-window`, `m3-window`).

## Статический режим (staticMode)

Компонент Window поддерживает статический режим работы через свойство `staticMode`. В этом режиме окно работает как встроенный компонент без модального поведения:

- **Содержимое отображается сразу** — окно не скрывается и не требует активации
- **Отключены анимации** — нет эффектов появления/исчезновения
- **Отключено позиционирование** — окно встраивается в поток документа
- **Работает с adaptive** — когда свойство `adaptive` имеет один из статичных режимов (например, `static`), включается статичный режим

Статический режим особенно полезен для встраивания содержимого окна непосредственно в интерфейс без модального поведения.

## Направление позиционирования (axis)

Управляет осью размещения окна относительно элемента-якоря. По умолчанию: `y`.

> Применяется только в режиме меню (`adaptive="menu"` или `adaptive="menuWindow"`).

**Возможные значения:**
- `'x'` — горизонтальная ось (слева или справа от якоря)
- `'y'` — вертикальная ось (сверху или снизу от якоря)
- `'on'` — поверх якоря (окно центрируется над элементом)

### Поведение

- Компонент автоматически выбирает сторону размещения с наибольшим доступным пространством
- При использовании контекстного меню (`contextmenu`) позиционирование происходит от координат курсора
- Окно всегда остается в пределах видимой области экрана (viewport)
- Отступ от якоря задается через свойство `indent` (по умолчанию 4px)

## Управление состоянием через v-model

Двусторонняя привязка состояния открытия окна через `v-model:open`.

**Параметры:**
- `open: boolean` — состояние открытия окна

```html
<script setup>
import { ref } from 'vue'

const isOpen = ref(false)
</script>

<template>
  <button @click="isOpen = true">Открыть</button>

  <Window v-model:open="isOpen">
    <template #default>
      <p>Содержимое окна</p>
      <button @click="isOpen = false">Закрыть</button>
    </template>
  </Window>
</template>
```

## Expose методы
### `id`

Уникальный идентификатор окна.

**Тип:** `string`

```html
<script setup>
const windowRef = ref()

onMounted(() => {
  console.log(windowRef.value.id) // "window-123"
})
</script>

<template>
  <Window ref="windowRef" />
</template>
```

## Слоты
### `control`

Слот для размещения элементов управления окном (кнопки закрытия, минимизации и т.д.).

**Параметры:**
- `props: WindowControlItem` — объект с данными управления окном

```html
<Window>
  <template #control="{ onclick, open }">
    <button @click="onclick">
      {{ open ? 'Закрыть' : 'Открыть' }}
    </button>
  </template>
</Window>
```

## События
### `window`

Событие срабатывает при изменении состояния окна (открытие/закрытие).

**Параметры:**
- `options: WindowEmitOptions` — объект с данными окна

**Структура WindowEmitOptions:**
- `id: string` — уникальный идентификатор окна
- `element: HTMLDivElement` — DOM элемент окна
- `control: HTMLElement` — DOM элемент управления
- `open: boolean` — состояние открытия окна (`true` - открыто, `false` - закрыто)

```html
<script setup>
const handleWindow = (options) => {
  console.log('ID окна:', options.id)
  console.log('Окно открыто:', options.open)
  console.log('Элемент окна:', options.element)
  console.log('Элемент управления:', options.control)
}
</script>

<template>
  <Window @window="handleWindow">
    <template #default>
      <p>Содержимое окна</p>
    </template>
  </Window>
</template>
```
