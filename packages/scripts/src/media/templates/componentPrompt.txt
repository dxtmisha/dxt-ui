Нужно подготовить документацию для компонента на языке [wikiLanguage]. Следуй строго формату и требованиям ниже. Не добавляй ничего лишнего вне описанного.
Стек Storybook 9.x, TypeScript, MDX.

компонент Canvas подключаеться из '@storybook/addon-docs/blocks'

====================================
1) Изучи текущий код компонента
====================================
```
[code]
```
Проанализируй структуру, props, события, слоты, типы, внутреннюю логику.

====================================
2) Добавь недостающие комментарии к типам
====================================
Добавь краткие одноязычные (на [wikiLanguage]) JSDoc-комментарии к отсутствующим типам и его свойство.
Код для испправления:
```ts
// types.ts
[types]
```
Ниже продублируй итог без обёртки:
[types]

Требования к комментариям:
- Однострочные для простых полей.
- Многострочные для блоков логики.
- Без дублирования очевидного.
- адаптированы к storybook.

Пример:
```ts
/**
 * Basic properties for image components.
 */
export interface IconPropsBasic<
  Image extends ImagePropsBasic = ImagePropsBasic
> extends SkeletonPropsInclude {
  // Status
  /** Active state of the icon */
  active?: boolean

  // Icon
  /** Значение основной иконки */
  icon?: ImageValue<Image>
  /** Значение активной иконки */
  iconActive?: ImageValue<Image>
}
```

====================================
3) Истории (stories) для Storybook
====================================
Создай только минимально необходимые примеры. Каждый пример — максимально простой, без лишних обёрток, только то, что демонстрирует суть.
Код для испправления:
```ts
// ComponentDoc.stories.ts
[stories]
```
Правила:
- Не трогать те сторис, который уже есть, только добавления.
- Не трогать const meta. НЕЧЕГО НЕ МЕНЯТЬ В META.
- Не трогать существующие константы.
- Не добавляй истории ради заполнения.
- Если компонент имеет разные режимы (например, состояния или варианты отображения), покажи по одному примеру.
- Имена историй — в стиле PascalCase без лишних слов.
- Минимизируй импорты: только то, что требуется.

====================================
4) MDX-документация (описание компонента)
====================================
Подготовь полное описание компонента в формате MDX. Строгая стилистика: никаких таблиц, никаких лишних разделов.
Код для испправления:
```md
// UiPlayerLite.mdx
[md]
```

Правила структуры MDX:
- В начале: [description] — Краткое описание назначения (1–3 предложения): максимально коротко передаёт суть компонента.
- Далее: основной текст (документация) — начинается без заголовка. Это [doc].
- Можно дорабатывать существующий текст, изменя, но не удалять. Удаляй только лишнее или не актуальный.
- Обязательно перечисли слоты (если есть) и события (если есть) в заданном формате.
- Не описывай props списком, если они простые. Подробно описывай только сложные связки (например, зависимые props) или составные типы.
- Пример использования — в конце соответствующего смыслового блока или в самом низу, если один общий пример.
- Слоты и события — строго в формате ниже. Если типов нет — блок с типом опускается.
- Добавит Canvas, если есть пример использования. Если нет — добавить сторис.

Формат слотов:
```
## Слоты
### `имяСлота`
Краткое описание назначения слота. Можно маркированным списком выделить особенности.
Если есть props, добавить описанике props. `props: any` - это значить что нету пропсов, его не надо писать.
Если слотов несколько — каждый с подпунктом `###`.
Если возврашет просто VNode, не надо описывать.
Не надо что то в такой типе `Этот слот принимает любые VNode и не передает никаких свойств.`
Если нету события, не описывать блок событий.
Если нету слотов, не описывать блок слотов.

Формат событий:
```
## События
### `имяСобытия`
Описание когда и зачем испускается.

Пример описания слота (не вставляй дословно, адаптируй):
### `suffix`

Слот для размещения контента в конце компонента, после основного содержимого.

**Возвращает:** `VNode` — элемент с классом `{className}__suffix` и атрибутом `data-event-type="suffix"`

```html
<Component>
  <template #suffix>
    <Icon name="check" />
  </template>
</Component>
```

### `control`

Слот для размещения элементов управления окном (кнопки закрытия, минимизации и т.д.).

**Параметры:**
- `props: WindowControlItem` — объект с данными управления окном

```html
<Window>
  <template #control="{ onclick, open }">
    <button @click="onclick">
      {{ open ? 'Закрыть' : 'Открыть' }}
    </button>
  </template>
</Window>
```

Пример описания события (адаптируй под контекст):
### `window`

Событие срабатывает при изменении состояния окна (открытие/закрытие).

**Параметры:**
- `options: WindowEmitOptions` — объект с данными окна

**Структура WindowEmitOptions:**
- `id: string` — уникальный идентификатор окна
- `element: HTMLDivElement` — DOM элемент окна
- `control: HTMLElement` — DOM элемент управления
- `open: boolean` — состояние открытия окна (`true` - открыто, `false` - закрыто)

```html
<script setup>
const handleWindow = (options) => {
  console.log('ID окна:', options.id)
  console.log('Окно открыто:', options.open)
  console.log('Элемент окна:', options.element)
  console.log('Элемент управления:', options.control)
}
</script>

<template>
  <Window @window="handleWindow">
    <template #default>
      <p>Содержимое окна</p>
    </template>
  </Window>
</template>
```


Пример использования Canvas:
<Canvas of={Chip.ChipSkeleton}/>

====================================
5) Итоговый возврат
====================================
Верни результат строго в формате (ничего лишнего до или после):
[types.ts]
#########
[ComponentDoc.stories.ts]
#########
[UiPlayerLite.mdx]

Где:
- не добавляй ничего лишнего. (типа ```ts)
- не оборачивай в блоки.
- не оборачивай в ```ts или что-то подбного.
- [types.ts] — итоговый блок типов с комментариями (only content, without file name comments).
- [ComponentDoc.stories.ts] — итоговый файл историй (only content, without file name comments).
- [UiPlayerLite.mdx] — итоговая MDX-документация (only content, without file name comments).

====================================
Ограничения и стилистика
====================================
- Никаких таблиц.
- Никаких произвольных дополнительных разделов.
- Не добавляй раздел "Props", если нет сложных зависимостей.
- Не дублируй описание одного и того же.
- Уважай язык [wikiLanguage] — если это "en" используй английский, иначе соответствующий язык.
- Не используй placeholder'ы вне оговорённых.
- Кодовые блоки: для типов и событий — ```ts, для разметки — ```html при необходимости.
- Сторисы: только необходимые сценарии, без лишних визуальных украшений.

====================================
Пример (не включать в ответ, только как ориентир стиля)
====================================
## Свойства выделения текста

Свойства `highlight` и `highlightLengthStart` предназначены для управления выделением текста в компонентах.

### Свойства

- **highlight** — Текст для выделения в содержимом компоненте
- **highlightLengthStart** — Минимальная длина значения highlight для начала выделения

### Взаимосвязь свойств

Свойства работают совместно для обеспечения интеллектуального выделения текста. `highlight` определяет что выделять, а `highlightLengthStart` контролирует когда начинать выделение.

- `highlight` содержит строку текста, которую нужно найти и выделить в компоненте
- `highlightLengthStart` устанавливает минимальную длину строки поиска для активации функции выделения
- Выделение активируется только когда длина `highlight` достигает значения `highlightLengthStart`
- Это предотвращает нежелательное выделение при вводе коротких строк поиска
- Оба свойства обеспечивают оптимальный пользовательский опыт при работе с поиском и фильтрацией
