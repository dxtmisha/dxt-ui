type CookieSameSite = 'strict' | 'lax';
type CookieOptions = {
    age?: number;
    sameSite?: CookieSameSite;
    arguments?: string[];
};
type IconsItem = string | Promise<string | any>;
type TranslateCode = string | string[];
type TranslateList<T extends TranslateCode[]> = {
    [K in T[number] as K extends readonly string[] ? K[0] : K]: string;
};
type TranslateItemOrList<T extends TranslateCode> = T extends string[] ? TranslateList<T> : string;
enum ApiMethodItem {
    get = "GET",
    post = "POST",
    put = "PUT",
    delete = "DELETE"
}
type ApiMethod = string & ApiMethodItem;
type ApiFetch = {
    api?: boolean;
    path?: string;
    pathFull?: string;
    method?: ApiMethod;
    request?: FormData | Record<string, any> | string;
    auth?: boolean;
    headers?: Record<string, string> | null;
    type?: string;
    toData?: boolean;
    global?: boolean;
    devMode?: boolean;
    hideError?: boolean;
    queryReturn?: (query: Response) => Promise<any>;
    globalPreparation?: boolean;
    globalEnd?: boolean;
    init?: RequestInit;
};
type ApiResponseItem = {
    path: string | RegExp;
    method: ApiMethod;
    request?: ApiFetch['request'] | '*any';
    response: any | ((request?: ApiFetch['request']) => any);
    disable?: any;
    isForGlobal?: boolean;
    lag?: any;
};
type ApiData<T> = T & {
    data?: T;
    success?: boolean;
};
type ApiPreparationEnd = {
    reset?: boolean;
    data?: any;
};
type ApiDefaultValue = Record<string, any>;
type ApiStatusItem = {
    status?: number;
    statusText?: string;
    error?: string;
    lastResponse?: any;
    lastMessage?: string;
};
type Undefined = undefined | null;
type EmptyValue = Undefined | 0 | false | '' | 'undefined' | 'null' | '0' | 'false' | '[]';
type NumberOrString = number | string;
type NumberOrStringOrBoolean = number | string | boolean;
type NumberOrStringOrDate = NumberOrString | Date;
type NormalOrArray<T = NumberOrString> = T | T[];
type NormalOrPromise<T> = T | Promise<T>;
type ObjectItem<T = any> = Record<string, T>;
type ObjectOrArray<T = any> = T[] | ObjectItem<T>;
type FunctionReturn<R = any> = () => R;
type FunctionVoid = () => void;
type FunctionArgs<T, R> = (...args: T[]) => R;
type FunctionAnyType<T = any, R = any> = (...args: T[]) => R;
type ItemList<T = any> = Record<string, T>;
type Item<V> = {
    index: string;
    value: V;
};
type ItemValue<V> = {
    label: string;
    value: V;
};
type ItemName<V> = {
    name: string | number;
    value: V;
};
type ElementOrWindow = HTMLElement | Window;
type ElementOrString<E extends ElementOrWindow> = E | string;
type EventOptions = AddEventListenerOptions | boolean | undefined;
type EventListenerDetail<O extends Event, D extends Record<string, any>> = (event: O, detail?: D) => void;
type EventActivityItem<E extends ElementOrWindow> = {
    element: E | undefined;
    type: string;
    listener?: (event: any | Event) => void;
    observer?: ResizeObserver;
};
type ImageCoordinator = {
    x: number;
    y: number;
};
type GeoDate = 'full' | 'datetime' | 'date' | 'year-month' | 'year' | 'month' | 'day' | 'day-month' | 'time' | 'hour-minute' | 'hour' | 'minute' | 'second';
type GeoFirstDay = 1 | 6 | 0;
type GeoHours = '12' | '24';
type GeoTimeZoneStyle = 'minute' | 'hour' | 'ISO8601' | 'RFC';
interface GeoItem {
    country: string;
    countryAlternative?: string[];
    language: string;
    languageAlternative?: string[];
    firstDay?: string | null;
    zone?: string | null;
    phoneCode?: string;
    phoneWithin?: string;
    phoneMask?: string | string[];
    nameFormat?: 'fl' | 'fsl' | 'lf' | 'lsf' | string;
}
interface GeoItemFull extends Omit<GeoItem, 'firstDay'> {
    standard: string;
    firstDay: string;
}
interface GeoFlagItem {
    language: string;
    country: string;
    standard: string;
    icon?: string;
    label: string;
    value: string;
}
interface GeoFlagNational extends GeoFlagItem {
    description: string;
    nationalLanguage: string;
    nationalCountry: string;
}
interface GeoPhoneValue {
    phone: number;
    within: number;
    mask: string[];
    value: string;
}
interface GeoPhoneMap {
    items: GeoPhoneValue[];
    info: GeoPhoneValue | undefined;
    value: string | undefined;
    mask: string[];
    maskFull: string[];
    next: Record<string, GeoPhoneMap>;
}
interface GeoPhoneMapInfo {
    item?: GeoPhoneMap;
    phone?: string;
}